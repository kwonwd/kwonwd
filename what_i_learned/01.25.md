# 예외처리

- Before starting, why we need exception?
  - uncertainty, not almost perpect

- 프로그램의 오류
  - 어떤 원인에 의해 오동작 하거나 비정상적으로 종료되는 경우
  - 발생시점에 따라 구분이 가능
    - 컴파일 에러
      - 컴파일이 되지 않음, 문법이 틀려서
    - 런타임 에러
      - 컴파일은 되었음, 실행도 됨, 실행 과정 중에 문제 ex) null pointer, parameter, index
    - 논리적 에러
      - 실행도 되는데, 결과가 원하는 결과가 아님

- 에러와 예외
  - 예외는 처리를 하지만 에러는 처리를 하지 않음
  - 에러 - Error : 발생하면 복구할 수 없는 심각한 문제
    - 합리적인 플로그램이면 굳이 처리하지 않는다.
    - ex) 메모리 부족, 스택 오버 플로우(스택의 크기는 기본적으로 8000 정도)
  - 예외 - Exception : 프로그래머가 적절한 코드를 통해 대비할 수 있는 오류
    - 예외는 사건이다, 실행 중에 발생하는, 정상적인 흐름을 방해한다.
    - 클래스 형변환 실패
    - 파일 읽기 실패

- 예외처리
  - 예외 발생 시 프로그램의 비 정상 종료를 막고 정상적인 실행 상태를 유지하는 것
  - 예외의 감지 및 예외 발생 시 동작할 코드 작성 필요(예방)

- 예외 클래스의 계층
  - ppt 보기
  - throw - 예외 발생 할 수 있는 것
  - 빨간색 - 신경 쓸 필요 X
  - 노란색 - Checked Exception 컴파일 할 때 체크
  - 파란색 - Unchecked Exception 

- 예외의 계열
  - RuntionException 클래스들
    - 프로그래머의 실수로 발생하는 계열
    - 대처 코드가 없어도 컴파일 문제 x
    - (중요)'Unchecked Exception'
  - Exception 클래스들
    - 사용자의 실수 등 외적인 요인에 의해 발생하는 계열
    - 대처 코드가 없으면 컴파일 진행x
    -  (중요)'Checked Exception'
  

- 예외 처리 키워드
  - 직접 처리
    - try
    - catch
    - finally
  - 간접 처리
    - throws
  - 사용자 정의 예외 발생시킬 때
    - throw

- 예외 처리(try ~ catch 구문)// 좀 이따가 다시 보기 28분 경
  - 프로그램 실행 시 발생할 수 있는 예외에 대한 대비코드 작성
  - 비정상적인 종료를 막고, 정상적인 상태를 유지함
  - 예외 발생시 JVM의 예외처리기가 닫아서 처리
```
try{
    // 예외가 발생할 수 있는 코드
} catch (Exception e){
    // 예외가 발생했을 때 처리할 코드
}
```
  - 중괄호(블록) 생략 불가능
  - 블럭안에 또다른 try ~ catch 구문이 올 수 있음

- 다중 예외처리
  - try 블록에서 여러종류의 예외가 발생할 경우
  - 하나의 try블록에 여러개의 catch 블록 추가 가능

- 다중 예외처리 유의 사항
  - JVM이 던진 예외는 catch 문장을 찾을 때는 다형성이 적용됨
  - 상위 타입의 예외가 먼저 선언 되는 경우 뒤에 등장하는 catch 블록은 동작할 기회가 없음
  - 상속 관계가 없는 경우는 무관
  - '상속 관계에서는 작은 범위(자식)에서 큰 범위(조상)순으로 정의'

- Exception 인스턴스의 주요 메서드
  - `getMessage()` : 발생된 예외에 대한 구체적인 메시지를 반환
  - `printStackTrace()` : 예외 발생 당시의 호출 스택(Call Stack)을 출력한다

- 메서드에서 예외 던지기(간접)
  - 메서드 선언부에 throws 키워드를 사용하여 예외 작성
  - 예외가 여러 개일 경우',' 를 이용하여 나열
  - 메서드가 예외를 처리하는 것이 아닌 전달(나 자신을 호출한 곳으로)
  - 조상 타입의 예외로 처리 가능

- checked exception 과 throws
- runtime(unchecked) exception 과 throws
  - 코드를 보세요

- 메서드 재정의와 throws
  - 메서드 재정의 시 조상클래스 메서드가 던지는 예외보다 부모 예외를 던질 수 없다.

- (중요) finally 구문
  - finally는 예외 발생 여부와 상관 없이 언제나 실행
```
  try{
    // 예외가 발생할 수 있는 코드
} catch (Exception e){
    // 예외가 발생했을 때 처리할 코드
}finally{
    예외 상관없이 항상 수행해야 하는 코드
}
```
  - 중간에 return이 있어도 finally 블록 수행 후 반환

- (중요)자동 자원 반납 구문 (try with resources) - 시스템 자원을 사용
  - 자원 등을 반납할 때 finally에서 close()를 통해 반납을 주로함
  - 코드가 지저분해 지고 다른 예외상황을 발생시킬 수 있음
  - try() -> 괄호 안에 객체를 생성하는 코드를 작성하면, 해당 객체는 close()를 호출하지 않아도 블록을 벗어 나는 순간 close()가 호출됨
  - 해당 객체의 클래스가 AutoCloseable이라는 인터페이스를 구현한 클래스이어야만 함

- 사용자 정의 예외
  - 기존에 정의된 예외 이외에 사용자가 직접 정의 예외를 작성할 수 있음
  - 대부분 Exception 또는 RuntimeException 클래스를 상속 받아 작성
    - checked exception 활용
    - runtime exception 활용
