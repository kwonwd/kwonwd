# 추상클래스

- 클래스 중에는 실제로는 필요하지 않는 메서드가 있지 않을까? => 추상 클래스
  - 그렇다고 해서 삭제는 할수 없음
  - 메서드의 선언부만 남기고 구현부는 ;으로 대체
  - 구현부가 없으므로 `abstract` 키워드를 메서드 선언부에 추가
    - 객체를 생성할 수 없는 클래스라는 의미로 클래스 선언부에 `abstract`를 추가
- 추상클래스 특징
  - abstract 클래스는 상속 전용의 클래스
  - 클래스에 구현부가 없는 메서드(추상 메서드)가 있으므로 객체를 생성할 수 없음
  - 상위 클래스 타입으로 자식을 참조할 수는 있음
  - 조상 클래스에서 상속 받은 abstract 메서드를 재정의 하지 않는 경우, 클래스 내부에 abstract 메서드가 있으므로 자식 클래스는 abstract 클래스가 되어야 함
- 추상클래스 사용하는 이유
  - abstract 클래스는 구현의 강제를 통해 프로그램의 안정성 향상

# 인터페이스

- 인터페이스?
  - 서로 다른 장치들을 연결시켜 주는 규격(약속)
- 인터페이스
  - 완벽히 추상화된 설계도
  - 클래스와 유사하게 작성이 가능(class 대신 interface 키워드 사용)
  - 모든 메서드가 추상 메서드 => 이러이러한 메서드를 구현하겠다 라는 강제성
```
public interface 인터페이스 이름{
    (public static final) 타입 상수이름1=10;
    (생략가능) 타입 상수이름 상수이름2=10;

    (public abstract) 반환형 메서드이름1(타입 매개변수...);
    (생략가능) 반환형 메서드이름2(타입 매개변수...);
}
``` 
- 인터페이스 구현
  - 인터페이스는 그 자체로 인스턴스를 생성할 수 없음 (구현부X)
  - 인터페이스 내에 있는 메서드를 구현할 클래스가 필요함
  - extends 대신 `implements` 키워드를 사용하여 구현 클래스 작성
  - `interface Shape {}`
  - `class Circle extends Shape {}` X
  - `Class Cirle implements Shape{}` O
    - 여러개의 interface implements 가능
    - `클래스 >(상속) 클래스 (단일 상속)`
    - `클래스 >(구현) 인터페이스 (다중구현)`
    - `인터페이스 >(상속) 인터페이스 (다중상속)`
      - 추상메서드를 상속 받기 때문에 어쩌피 오버라이드 해줘야 해서 다중상속이 가능하다.
  - 인터페이스를 구현하는 쿨래스는 추상메서드를 반드시 오버라이딩(재정의) 해야한다.
  - 다형성 적용
  - 인터페이스 상속
    - extends를  이용하여 상속이 가능
    - 다중 상속이 가능
- default method
  - 인터페이스 구현부가 있는 메서드를 작성할 수 있음
  - 메서드 앞에 default라는 키워드를 작성 해야함
  - public 접근 제한자를 사용해야 하며 생략 가능
    - 구현부 > 인터페이스 끼리의 충돌발생 가능 > 반드시 오버라이드 해야함
    - 인터페이스의 default하고 부모클래스 일반 메서드가 충돌할 수 있음
      - 이때는 부모클래스가 사용된다.
- static method
  - 객체 생성 없이 클래스명.메서드명()처럼 인터페이스명.메서드명() 으로 사용함 
  - 클래스이 static 메서드와 사용방법이 동일함
  - 인터페이스 이름으로 메서드에 접근하여 사용
- 인터페이스의 필요성
  - 표준화 처리 가능
  - 개발 기간 단축 가능
  - 서로 관계가 없는 클래스들에게 인터페이스를 통해 관계를 맺을 수 있음
  - 인터페이스를 통한 간접적인 클래스 사용으로 손쉬운 모듈 교체 지원
  - 독립적 프로그래밍 가능

- 클래스 vs 인터페이스
  - ppt 보세요
- 추상클래스 vs 인터페이스
  - 이것도 ppt 보세요


# Generic

- 제네릭
  - 다양한 종류의 객체들을 다루는 메서드나 컬렉션 클래스에서 컴파일 시 타입을 체크 해주는 기능
    - 여러타입의 클래스> 타입을 파라미터처럼 사용 > 타입에 대해 일반화
  - 객체의 타입 안정성을 제공한다.
  - 형변환의 번거로움이 없어지므로 코드가 간결해진다.
- 제네릭 클래스
  - 클래스를 정의할 때
  - 클래스 안에서 사용되는 자료형(타입)을 구체적으로 명시하지 않고
  - T와 같이 '타입 매개변수'를 이용하는 클래스
- 제네릭 클래스 선언
  - 클래스 또는 인터페이스 선언시 <>에 타입 파라미터 표시
```
public class ClassName<T>{}
public interface InterfaceName<T>{}
```

  - 타입 파라미터 > 특별한 의미의 알파벳보다는 단순히 임의의 참조형 타입을 말함
- 제네릭 클래스 객체 생성
  - 변수와 생성 쪽의 타입은 반드시 일치해야 함. (상속관계에 있어도 마찬가지)
```
Box<Student> box =new Box<Student>(); (O)
Box<Person> box = new Box<Student>(); (X)

```
  - 추정이 가능한 경우 타입 생략 가능
  - `Box<Student> box = new Box<>();` 에 Student 생략
- 제한된 제네릭 클래스
  - 타입 문자로 사용할 타입을 명시하였지만 역시 모든 타입을 사용할 수 있는 문제가 발생
  - 구체적인 타입의 제한이 필요할 때 extends 키워드를 사용할 수 있음
  - 클래스가 아닌 인터페이스로 제한할 경우도 extends 키워드 사용
  - 클래스와 함께 인터페이스 제약 조건을 이용할 경우 & 로 연결
- 와일드 카드 이용
  - 타입으로 활용할 때 사용( 변수로 쓸 때)
  - `Generic type<?>` 타입에 제한이 없음
  - `Generic type<? extends T>` T와 T를 상속받은 타입들만 사용 가능
  - `Generic type<? super T>` T와 T의 조상 타입만 사용 가능