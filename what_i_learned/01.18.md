# 객체지향 프로그래밍(Object Oriented Programming)

- java에서 이야기하는 객체 - 데이터(속성)와 데이터가 이야기하는 알고리즘(로직) 을 객체라 한다.
  - *(중요)*클래스(class) - 객체를 만드는 설계도(Blueprint) '=, 붕어빵 틀
  - 인스턴스(Instance) - 클래스를 통해 생성된 객체

- *(중요)*객체지향 프로그래밍 특징(A PIE)
  - Abstraction(추상화)
    - 현실객체>SW객체 ex)개인정보
  - Polymorphism(다형성)
    - 하나의 객체를 다양한 형으로 참조(관점)할 수 있다 ex) 학생, 환자, 고객
  - Inheritance(상속)
    - 기존의 클래스를 재활용> 새로운 클래스 ex) 사람이라는 클래스를 학생이라는 클래스에 재사용
  - Encapsulation(캡슐화)
    - 데이터와 로직을 캡슐화
    - 개체의 속성,행위 - 공개 or 비공개 for 정보보호

- *(중요)*객체지향 프로그래밍 장점
  - 모듈화된 프로그래밍(modulated)
    - 각각의 모듈을 개별적으로 관리 가능
  - 재사용성이 높다
  - 디버깅이 용이함
  - 정보보호 측면에서 유리
  - 협업이 쉽다

## 클래스

- 클래스
  - 관련 있는 변수와 함수(메서드)를 묶어서 만든 사용자정의 <자료형>
  - 모든 객체들의 생산처
  - 클래스 == 객체를 생성하는 틀
  - 클래스를 통해 생성된 객체 == 인스턴스

- (중요)클래스 구성
  - 속성(attribute) - 필드
  - 동작(Behavior) - 메소드
  - 생성자(Constructor)
  - 중첩클래스(클래스 내부의 클래스)

- 클래스 선언 및 객체의 생성
  
  ```
    [접근제한자] [활용제한자] class 클래스명 { 
        속성 정의(필드)
        기능 정의 (메소드) 
        생성자
    }   
    ```

- [접근제한자]
  - public(다른 패키지 접근 가능)/ default(같은 패키지에서만)
- [활용제한자]
  - final(상속 X)/ abstract(추상클래스)

- 변수
  - 클래스변수
    - 설계도에 들어잇는 변수
    - 클래스 영억 선언 static 키워드
    - 생성시기 : 클래스가 메모리에 올라갔을 때
    - (중요)모든 인스턴스가 공유함
  - 인스턴스 변수
    - 실제로 만들어진 객체
    - 힙 영역 선언
    - 생성시기 : 인스턴스가 생성되었을 때 (new)
    - 인스턴스 별로 생성됨
  - 지역변수
    - 클래스 영역 이외
    - 생성시기 : 선언 되었을 때

- 메소드
  - 객체가 할수 있는 행동을 정의
  - 어떤 작업을 수행하는 명령문의 집합에 이름을 붙여 놓은 것
  - 메소드의 이름은 소문자로 시작하는 것이 관례

```
    [접근제한자][활용제한자] 반환값 메소드이름([매개변수들]){

    행위 기술

    }
```
- 메소드 선언
  - 선언시 {} 안에 메소드가 해야할 일을 정의
- 메소드 호출
  - 객체를 생성한 후 객체의 멤버 메서드를 호출한다.
  - static이 메소드에 선언 되어 있을 때는 클래스이름.메소드 이름으로 호출
- 메소드
  - 매개변수(Parameter)
    - 메소드에서 사용하는 것
    - `public void study(int time){}` 에서 'int time'임
  - 인자(argumaent)
    - 호출하는 쪽에서 전달하는 것
    - `Person p = new Person();p.study(10);` 에서 10임
  - 리턴 타입
    - 메소드를 선언할 때 지정, 없다면 void(return문 생략 가능)
    - 리턴 타입을 작성했다면 반드시 해당 타입의 값을 리턴
  - 메소드 오버로딩
    - 이름이 같고 매개변수가 다른 메소드를 여러 개 정의 하는 것
    - 파라미터의 개수 또는 순서, 타입이 달라야 할 것(파라미터 이름만 다른 것은 X)

- 생성자
  - new 키워드와 함께 호출하여 객체 생성 ex)`Person yang = new Person();` 에서 'Person()'가 생성자임
  - (중요)클래스명과 동일
  - 결과형 리턴값을 갖지 않음
  - (중요) 객체가 생성될 때 반드시 하나의 생성자 호출
  - (중요)멤버필드의 초기화에 주로 사용
  - (중요)하나의 클래스 내부에 생성자가 하나도 없으면 자동적으로 default 생성자가 있는 것으로 인지
- 기본(디폴트) 생성자
  - 클래스 내에 생성자가 하나도 정의되어 있지 않을 경우 JVM이 자동으로 제공하는 생성자
  - 형태" 매개변수가 없는 형태, `클래스명(){}`
  - 만약, 우리가 생성자를 하나라도 만들면 default 생성자가 자동으로 생성되지 않는다.
- 파라미터가 있는 생성자
  - 생성자의 목적이 필드 초기화
  - 해당 생성자를 작성하면 JVM에서 기본 생성자를 추가하지 않음




# 추가수업

- java >jre, javac> JVM 메모리 구조(Static, Heap, Stack)
- class를 선언하면 static에 저장이 됨
- 객체(인스턴스)는 'Heap'에 저장됨
- `Ssafy ssafy = new Ssafy();` 기준 클래스인 'Ssafy'는 static에 객체인 'ssafy'는 Heap에 저장이 됨
- 스택은 선입후출, 나중에 들어오면 먼저 나감
- 생성자
  - 